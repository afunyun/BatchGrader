<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="27" failures="64" skipped="0" tests="273" time="18.000" timestamp="2025-05-17T05:23:57.833024-05:00" hostname="PC1337"><testcase classname="tests.test_batch_job" name="test_batch_job_initialization" time="0.008" /><testcase classname="tests.test_batch_job" name="test_batch_job_status_transitions" time="0.005" /><testcase classname="tests.test_batch_job" name="test_batch_job_default_values" time="0.003" /><testcase classname="tests.test_batch_job" name="test_get_status_log_str" time="0.002" /><testcase classname="tests.test_batch_job" name="test_batch_job_token_tracking" time="0.002" /><testcase classname="tests.test_batch_job" name="test_batch_job_with_invalid_file" time="0.001" /><testcase classname="tests.test_batch_job" name="test_update_progress" time="0.003" /><testcase classname="tests.test_batch_job" name="test_get_progress_eta_str" time="0.003" /><testcase classname="tests.test_batch_runner" name="test_run_batch_processing_single_file" time="0.021"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x0000025615111C10&gt;, mock_args_input_file = &lt;MagicMock id='2570534147360'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_batch_processing_single_file(mocker, mock_args_input_file,
                                              basic_config):
&gt;       mock_process_file = mocker.patch('src.batch_runner.process_file',
                                         return_value=True)

tests\test_batch_runner.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                        within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_batch_processing_input_dir" time="0.008"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561518CE60&gt;, mock_args_input_dir = &lt;MagicMock id='2568744392064'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_batch_processing_input_dir(mocker, mock_args_input_dir,
                                            basic_config):
&gt;       mock_process_file = mocker.patch('src.batch_runner.process_file',
                                        return_value=True)

tests\test_batch_runner.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_process_file" time="0.006"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561518DCD0&gt;, mock_args_input_file = &lt;MagicMock id='2568744395376'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_process_file(mocker, mock_args_input_file, basic_config):
&gt;       mock_file_wrapper = mocker.patch('src.batch_runner.process_file_wrapper',
                                        return_value=True)

tests\test_batch_runner.py:157: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_count_mode_single_file" time="0.007"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x0000025615110E00&gt;, mock_args_input_file = &lt;MagicMock id='2568743887040'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_count_mode_single_file(mocker, mock_args_input_file,
                                        basic_config):
        mock_args_input_file.mode = 'count'
        # Create a consistent DataFrame for testing
        test_df = pd.DataFrame([{'text': 'sample data'}])
&gt;       mocker.patch('src.batch_runner.load_data', return_value=test_df)

tests\test_batch_runner.py:188: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_split_mode_single_file" time="0.006"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561518CEF0&gt;, mock_args_input_file = &lt;MagicMock id='2568744389472'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_split_mode_single_file(mocker, mock_args_input_file,
                                        basic_config):
        """Test split mode with a single input file."""
        # Mock the split_file_by_token_limit function
&gt;       mock_split = mocker.patch('src.batch_runner.split_file_by_token_limit')

tests\test_batch_runner.py:223: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_process_file_error_handling" time="0.011"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151AEF30&gt;, mock_args_input_file = &lt;MagicMock id='2568744519872'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_process_file_error_handling(mocker, mock_args_input_file,
                                         basic_config):
        """Test error handling in process_file function."""
        # Test FileNotFoundError
        mocker.patch('pathlib.Path.exists', return_value=False)
        result = process_file(str(mock_args_input_file.input_file),
                              str(mock_args_input_file.output_dir), basic_config)
        assert result is False
    
        # Test ValueError
        mocker.patch('pathlib.Path.exists', return_value=True)
&gt;       mocker.patch('src.batch_runner.load_system_prompt',
                     side_effect=ValueError("Invalid prompt"))

tests\test_batch_runner.py:254: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_token_cost_stats" time="0.002"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561518CD70&gt;, basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_token_cost_stats(mocker, basic_config):
        """Test token cost statistics functions."""
        # Mock LLMClient
        mock_llm = MagicMock()
        mock_llm.api_key = "test_key"
&gt;       mocker.patch('src.batch_runner.LLMClient', return_value=mock_llm)

tests\test_batch_runner.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_token_cost_summary" time="0.006"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151CAED0&gt;, tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_token_cost_summary0')
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_token_cost_summary(mocker, tmp_path, basic_config):
        """Test token cost summary function."""
        # Mock LLMClient
        mock_llm = MagicMock()
        mock_llm.api_key = "test_key"
&gt;       mocker.patch('src.batch_runner.LLMClient', return_value=mock_llm)

tests\test_batch_runner.py:296: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_batch_processing_error_handling" time="0.006"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151135C0&gt;, mock_args_input_file = &lt;MagicMock id='2568743892608'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}
tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_run_batch_processing_erro0')

    def test_run_batch_processing_error_handling(mocker, mock_args_input_file,
                                                 basic_config, tmp_path):
        """Test error handling in run_batch_processing."""
        # Mock log directory
        log_dir = tmp_path / "logs"
        archive_dir = log_dir / "archive"
&gt;       mocker.patch('src.batch_runner.get_log_dirs',
                     return_value=(log_dir, archive_dir))

tests\test_batch_runner.py:325: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_batch_processing_with_continue_on_failure" time="0.007"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151F18E0&gt;, tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_run_batch_processing_with0')
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_batch_processing_with_continue_on_failure(mocker, tmp_path,
                                                           basic_config):
        """Test batch processing with continue_on_failure option."""
        # Setup test files
        input_dir = tmp_path / "input_dir"
        input_dir.mkdir()
        (input_dir / "file1.csv").write_text("id,text\n1,test1")
        (input_dir / "file2.csv").write_text("id,text\n2,test2")
    
        mock_args = MagicMock(input_file=None,
                              input_dir=str(input_dir),
                              output_dir=str(tmp_path / "output"),
                              config_file=None,
                              log_dir=None,
                              mode='batch')
    
        # Mock process_file to fail for first file but succeed for second
&gt;       process_file_mock = mocker.patch('src.batch_runner.process_file')

tests\test_batch_runner.py:373: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_count_mode_error_handling" time="0.010"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151F2840&gt;, mock_args_input_file = &lt;MagicMock id='2568744805600'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_count_mode_error_handling(mocker, mock_args_input_file,
                                           basic_config):
        """Test error handling in run_count_mode."""
        mock_args_input_file.mode = 'count'
    
        # Test file not found
        mocker.patch('pathlib.Path.exists', return_value=False)
        run_count_mode(mock_args_input_file, basic_config)
    
        # Test encoder initialization failure
        mocker.patch('pathlib.Path.exists', return_value=True)
&gt;       mocker.patch('src.batch_runner.get_encoder', return_value=None)

tests\test_batch_runner.py:397: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_batch_runner" name="test_run_split_mode_error_handling" time="0.009"><failure message="AttributeError: module 'src' has no attribute 'batch_runner'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151F1310&gt;, mock_args_input_file = &lt;MagicMock id='2568744800128'&gt;
basic_config = {'examples_dir': 'tests/input/examples', 'global_token_limit': 2000000, 'input_splitter_options': {}, 'llm_client_options': {'api_key': 'TEST_KEY'}, ...}

    def test_run_split_mode_error_handling(mocker, mock_args_input_file,
                                           basic_config):
        """Test error handling in run_split_mode."""
        mock_args_input_file.mode = 'split'
    
        # Test file not found
        mocker.patch('pathlib.Path.exists', return_value=False)
        run_split_mode(mock_args_input_file, basic_config)
    
        # Test split failure
        mocker.patch('pathlib.Path.exists', return_value=True)
&gt;       mocker.patch('src.batch_runner.split_file_by_token_limit',
                     side_effect=Exception("Split error"))

tests\test_batch_runner.py:418: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.batch_runner'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'batch_runner'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[not_df-prompt-resp-dummy_encoder-10-TypeError-df must be a pandas DataFrame]" time="0.003" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df1-prompt-resp-dummy_encoder-10-ValueError-DataFrame cannot be empty]" time="0.003" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df2--resp-dummy_encoder-10-ValueError-system_prompt_content must be a non-empty string]" time="0.002" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df3-prompt--dummy_encoder-10-ValueError-response_field must be a non-empty string]" time="0.002" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df4-prompt-resp-dummy_encoder-10-ValueError-response_field 'resp' not found]" time="0.002" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df5-prompt-resp-dummy_encoder-0-ValueError-token_limit must be a positive integer]" time="0.002" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_errors[df6-prompt-resp-None-10-ValueError-encoder cannot be None]" time="0.002" /><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_success_under_limit" time="0.007"><failure message="RuntimeError: Error checking token limits: dummy_encoder() missing 2 required positional arguments: 'resp' and 'encoder'">df =   resp
0    a
1   bb
2  ccc, system_prompt_content = 'X', response_field = 'resp', encoder = &lt;function dummy_encoder at 0x000002567FF0DBC0&gt;, token_limit = 100, raise_on_error = True, filepath = None

    def check_token_limits(
            df: pd.DataFrame,
            system_prompt_content: str,
            response_field: str,
            encoder: Any,
            token_limit: int,
            raise_on_error: bool = False,
            filepath: Optional[str] = None) -&gt; Tuple[bool, Dict[str, float]]:
        """
        Check if token counts in the dataframe exceed the specified limit.
    
        Args:
            df: Input dataframe to check. Must be a non-empty pandas DataFrame.
            system_prompt_content: System prompt content or field name. Must be a non-empty string.
            response_field: Field containing response content. Must be a column in the DataFrame.
            encoder: Tokenizer encoder instance.
            token_limit: Maximum allowed tokens. Must be a positive integer.
            raise_on_error: If True, raises ValueError on validation errors.
    
        Returns:
            Tuple containing:
                - Boolean indicating if tokens are under limit
                - Dictionary with token statistics (total, average, max)
    
        Raises:
            ValueError: If input validation fails and raise_on_error is True.
            TypeError: If input types are incorrect and raise_on_error is True.
        """
        # Input validation
        if not isinstance(df, pd.DataFrame):
            error_msg = f"df must be a pandas DataFrame, got {type(df).__name__}"
            if raise_on_error:
                raise TypeError(error_msg)
            logger.error(error_msg)
            return False, {}
    
        if df.empty:
            return _handle_dataframe_error("DataFrame cannot be empty",
                                           raise_on_error, logger)
    
        if not isinstance(system_prompt_content,
                          str) or not system_prompt_content.strip():
            return _handle_validation_error(
                "system_prompt_content must be a non-empty string", raise_on_error,
                logger)
    
        if not isinstance(response_field, str) or not response_field.strip():
            return _handle_validation_error(
                "response_field must be a non-empty string", raise_on_error,
                logger)
    
        if response_field not in df.columns:
            return _handle_validation_error(
                f"response_field '{response_field}' not found in DataFrame columns",
                raise_on_error, logger)
    
        if not isinstance(token_limit, int) or token_limit &lt;= 0:
            return _handle_validation_error(
                f"token_limit must be a positive integer, got {token_limit}",
                raise_on_error, logger)
    
        if encoder is None:
            return _handle_validation_error(
                "encoder cannot be None, or tiktoken.Encoding, or a callable.",
                raise_on_error, logger)
    
        try:
            token_counter = create_token_counter(system_prompt_content,
                                                 response_field, encoder)
&gt;           token_counts = df.apply(token_counter, axis=1)

src\batchgrader\file_processor.py:174: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\site-packages\pandas\core\frame.py:10374: in apply
    return op.apply().__finalize__(self, method="apply")
C:\Python312\Lib\site-packages\pandas\core\apply.py:916: in apply
    return self.apply_standard()
C:\Python312\Lib\site-packages\pandas\core\apply.py:1063: in apply_standard
    results, res_index = self.apply_series_generator()
C:\Python312\Lib\site-packages\pandas\core\apply.py:1081: in apply_series_generator
    results[i] = self.func(v, *self.args, **self.kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

row = resp    a
Name: 0, dtype: object

    def token_counter(row: Dict[str, Any]) -&gt; int:
        user_content = str(row.get(response_field, ''))
        system_content = system_prompt_content
    
        if prompt_template:
            prompt_text = prompt_template.format(system=system_content,
                                                 user=user_content)
        else:
            prompt_text = f"{system_content}\n{user_content}"
    
        # Use encode method if available, else assume encoder is callable
        if hasattr(encoder, 'encode'):
            return len(encoder.encode(prompt_text))
        elif callable(encoder):
&gt;           return encoder(prompt_text)
E           TypeError: dummy_encoder() missing 2 required positional arguments: 'resp' and 'encoder'

src\batchgrader\token_utils.py:113: TypeError

The above exception was the direct cause of the following exception:

    def test_check_token_limits_success_under_limit():
        df = pd.DataFrame({'resp':["a","bb","ccc"]})
&gt;       is_valid, stats = check_token_limits(df, "X", "resp", dummy_encoder, 100, raise_on_error=True)

tests\test_check_token_limits.py:28: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

df =   resp
0    a
1   bb
2  ccc, system_prompt_content = 'X', response_field = 'resp', encoder = &lt;function dummy_encoder at 0x000002567FF0DBC0&gt;, token_limit = 100, raise_on_error = True, filepath = None

    def check_token_limits(
            df: pd.DataFrame,
            system_prompt_content: str,
            response_field: str,
            encoder: Any,
            token_limit: int,
            raise_on_error: bool = False,
            filepath: Optional[str] = None) -&gt; Tuple[bool, Dict[str, float]]:
        """
        Check if token counts in the dataframe exceed the specified limit.
    
        Args:
            df: Input dataframe to check. Must be a non-empty pandas DataFrame.
            system_prompt_content: System prompt content or field name. Must be a non-empty string.
            response_field: Field containing response content. Must be a column in the DataFrame.
            encoder: Tokenizer encoder instance.
            token_limit: Maximum allowed tokens. Must be a positive integer.
            raise_on_error: If True, raises ValueError on validation errors.
    
        Returns:
            Tuple containing:
                - Boolean indicating if tokens are under limit
                - Dictionary with token statistics (total, average, max)
    
        Raises:
            ValueError: If input validation fails and raise_on_error is True.
            TypeError: If input types are incorrect and raise_on_error is True.
        """
        # Input validation
        if not isinstance(df, pd.DataFrame):
            error_msg = f"df must be a pandas DataFrame, got {type(df).__name__}"
            if raise_on_error:
                raise TypeError(error_msg)
            logger.error(error_msg)
            return False, {}
    
        if df.empty:
            return _handle_dataframe_error("DataFrame cannot be empty",
                                           raise_on_error, logger)
    
        if not isinstance(system_prompt_content,
                          str) or not system_prompt_content.strip():
            return _handle_validation_error(
                "system_prompt_content must be a non-empty string", raise_on_error,
                logger)
    
        if not isinstance(response_field, str) or not response_field.strip():
            return _handle_validation_error(
                "response_field must be a non-empty string", raise_on_error,
                logger)
    
        if response_field not in df.columns:
            return _handle_validation_error(
                f"response_field '{response_field}' not found in DataFrame columns",
                raise_on_error, logger)
    
        if not isinstance(token_limit, int) or token_limit &lt;= 0:
            return _handle_validation_error(
                f"token_limit must be a positive integer, got {token_limit}",
                raise_on_error, logger)
    
        if encoder is None:
            return _handle_validation_error(
                "encoder cannot be None, or tiktoken.Encoding, or a callable.",
                raise_on_error, logger)
    
        try:
            token_counter = create_token_counter(system_prompt_content,
                                                 response_field, encoder)
            token_counts = df.apply(token_counter, axis=1)
    
            if token_counts.empty:
                return True, {'total': 0, 'average': 0, 'max': 0}
    
            token_stats = {
                'total': float(token_counts.sum()),
                'average': float(token_counts.mean()),
                'max': float(token_counts.max())
            }
    
            is_under_limit = token_stats['total'] &lt;= token_limit
    
            logger.debug(f"[TOKEN COUNT] Total: {int(token_stats['total'])}, "
                         f"Avg: {token_stats['average']:.1f}, "
                         f"Max: {int(token_stats['max'])}")
    
            if not is_under_limit:
                try:
                    llm_client = LLMClient()
                    # Log a zero-cost event specifically indicating a limit was exceeded *before* raising.
                    update_token_log(api_key=llm_client.api_key,
                                     tokens_submitted=0,
                                     tokens_used_for_error=True,
                                     log_path=DEFAULT_TOKEN_USAGE_LOG_PATH)
                except Exception as e:
                    logger.error(
                        f"[WARN] Could not log token usage detail for limit exceeded event: {e}"
                    )
                error_location = f"for {filepath}" if filepath else "for an input dataframe"
                # Include token_stats in the error for better diagnostics
                details = f"Details: {token_stats['total']:.0f} tokens ({token_stats['average']:.1f} avg, {token_stats['max']:.0f} max) vs limit {token_limit:.0f}."
                raise TokenLimitError(
                    f"Token limit exceeded {error_location}. {details}")
            try:
                llm_client = LLMClient()
                update_token_log(llm_client.api_key,
                                 int(token_stats['total']),
                                 log_path=DEFAULT_TOKEN_USAGE_LOG_PATH)
            except Exception as e:
                logger.error(f"[WARN] Could not log token usage: {e}")
            return is_under_limit, token_stats
    
        except Exception as e:
            error_msg = f"Error checking token limits: {str(e)}"
            logger.error(error_msg, exc_info=True)
            if raise_on_error:
&gt;               raise RuntimeError(error_msg) from e
E               RuntimeError: Error checking token limits: dummy_encoder() missing 2 required positional arguments: 'resp' and 'encoder'

src\batchgrader\file_processor.py:221: RuntimeError</failure></testcase><testcase classname="tests.test_check_token_limits" name="test_check_token_limits_exceed_limit" time="0.003"><failure message="KeyError: 'total'">def test_check_token_limits_exceed_limit():
        df = pd.DataFrame({'resp':["aaaa"]})
        # token count = len(prompt)+len(resp)=1+4=5, limit=4 =&gt; exceed
        is_valid, stats = check_token_limits(df, "Z", "resp", dummy_encoder, 4, raise_on_error=False)
        assert not is_valid
&gt;       assert stats['total'] == float(len("Z")+4)
E       KeyError: 'total'

tests\test_check_token_limits.py:39: KeyError</failure></testcase><testcase classname="tests.test_cli" name="test_cli_batch_mode_input_file" time="0.034" /><testcase classname="tests.test_cli" name="test_cli_count_mode_input_dir" time="0.020" /><testcase classname="tests.test_cli" name="test_cli_split_mode_log_dir" time="0.020" /><testcase classname="tests.test_cli" name="test_cli_missing_input_defaults_to_input_dir" time="0.008"><failure message="ImportError: import error in src.constants: No module named 'src.constants'">name = 'src.constants'

    def resolve(name: str) -&gt; object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
&gt;               __import__(used)
E               ModuleNotFoundError: No module named 'src.constants'

C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:77: ModuleNotFoundError

The above exception was the direct cause of the following exception:

monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x00000256157053A0&gt;, mock_sys_argv = &lt;function mock_sys_argv.&lt;locals&gt;._mock_sys_argv at 0x0000025615710900&gt;
mock_batch_runner_functions = {'batch': &lt;MagicMock name='run_batch_processing' id='2568750137264'&gt;, 'count': &lt;MagicMock name='run_count_mode' id='2568750931248'&gt;, 'split': &lt;MagicMock name='run_split_mode' id='2568750938928'&gt;}
mock_load_config = &lt;MagicMock name='load_config' id='2568750372704'&gt;, tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_cli_missing_input_default0')

    def test_cli_missing_input_defaults_to_input_dir(monkeypatch, mock_sys_argv, mock_batch_runner_functions, mock_load_config, tmp_path):
        # Simulate input/ directory with a file
        input_dir = tmp_path / "input"
        input_dir.mkdir()
        (input_dir / "data.csv").write_text("id,text\n1,data")
&gt;       monkeypatch.setattr("src.constants.PROJECT_ROOT", tmp_path)

tests\test_cli.py:138: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:102: in derive_importpath
    target = resolve(module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.constants'

    def resolve(name: str) -&gt; object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
                __import__(used)
            except ImportError as ex:
                expected = str(ex).split()[-1]
                if expected == used:
                    raise
                else:
&gt;                   raise ImportError(f"import error in {used}: {ex}") from ex
E                   ImportError: import error in src.constants: No module named 'src.constants'

C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:83: ImportError</failure></testcase><testcase classname="tests.test_cli" name="test_cli_missing_input_and_empty_input_dir" time="0.010"><failure message="ImportError: import error in src.constants: No module named 'src.constants'">name = 'src.constants'

    def resolve(name: str) -&gt; object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
&gt;               __import__(used)
E               ModuleNotFoundError: No module named 'src.constants'

C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:77: ModuleNotFoundError

The above exception was the direct cause of the following exception:

monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x0000025615742630&gt;, mock_sys_argv = &lt;function mock_sys_argv.&lt;locals&gt;._mock_sys_argv at 0x0000025615710180&gt;
mock_batch_runner_functions = {'batch': &lt;MagicMock name='run_batch_processing' id='2568750016144'&gt;, 'count': &lt;MagicMock name='run_count_mode' id='2568750014464'&gt;, 'split': &lt;MagicMock name='run_split_mode' id='2568749927840'&gt;}
mock_load_config = &lt;MagicMock name='load_config' id='2568749932304'&gt;, tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_cli_missing_input_and_emp0'), capfd = &lt;_pytest.capture.CaptureFixture object at 0x0000025615705760&gt;

    def test_cli_missing_input_and_empty_input_dir(monkeypatch, mock_sys_argv, mock_batch_runner_functions, mock_load_config, tmp_path, capfd):
        # Simulate empty input/ directory
        input_dir = tmp_path / "input"
        input_dir.mkdir()
&gt;       monkeypatch.setattr("src.constants.PROJECT_ROOT", tmp_path)

tests\test_cli.py:155: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:102: in derive_importpath
    target = resolve(module)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.constants'

    def resolve(name: str) -&gt; object:
        # Simplified from zope.dottedname.
        parts = name.split(".")
    
        used = parts.pop(0)
        found: object = __import__(used)
        for part in parts:
            used += "." + part
            try:
                found = getattr(found, part)
            except AttributeError:
                pass
            else:
                continue
            # We use explicit un-nesting of the handling block in order
            # to avoid nested exceptions.
            try:
                __import__(used)
            except ImportError as ex:
                expected = str(ex).split()[-1]
                if expected == used:
                    raise
                else:
&gt;                   raise ImportError(f"import error in {used}: {ex}") from ex
E                   ImportError: import error in src.constants: No module named 'src.constants'

C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\_pytest\monkeypatch.py:83: ImportError</failure></testcase><testcase classname="tests.test_cli" name="test_cli_default_output_dir" time="0.021" /><testcase classname="tests.test_cli" name="test_cli_load_config_file_not_found" time="0.007"><failure message="AttributeError: module 'src' has no attribute 'cli'">mock_sys_argv = &lt;function mock_sys_argv.&lt;locals&gt;._mock_sys_argv at 0x0000025615137D80&gt;
mock_batch_runner_functions = {'batch': &lt;MagicMock name='run_batch_processing' id='2568750168880'&gt;, 'count': &lt;MagicMock name='run_count_mode' id='2568750160576'&gt;, 'split': &lt;MagicMock name='run_split_mode' id='2568750155104'&gt;}
mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561570FEF0&gt;, tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_cli_load_config_file_not_0')

    def test_cli_load_config_file_not_found(mock_sys_argv,
                                            mock_batch_runner_functions, mocker,
                                            tmp_path):
        input_file = tmp_path / "input.csv"
        input_file.write_text("id,text\n1,test")
        non_existent_config = tmp_path / "non_existent_config.yaml"
    
&gt;       mocker.patch(
            'src.cli.load_config',  # Corrected src. prefix
            side_effect=FileNotFoundError("Config not found"))

tests\test_cli.py:201: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.cli'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'cli'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_cli_additional" name="test_main_help" time="0.006" /><testcase classname="tests.test_cli_additional" name="test_main_modes[batch-run_batch_processing]" time="0.005" /><testcase classname="tests.test_cli_additional" name="test_main_modes[count-run_count_mode]" time="0.005" /><testcase classname="tests.test_cli_additional" name="test_main_modes[split-run_split_mode]" time="0.006" /><testcase classname="tests.test_cli_additional" name="test_main_unsupported_mode" time="0.005"><failure message="assert 2 == 1&#10; +  where 2 = SystemExit(2).code&#10; +    where SystemExit(2) = &lt;ExceptionInfo SystemExit(2) tblen=7&gt;.value">monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x00000256156FE390&gt;

    def test_main_unsupported_mode(monkeypatch):
        monkeypatch.setattr(cli, 'setup_logging', lambda log_dir: None)
        monkeypatch.setattr(cli, 'load_config', lambda config_file: {})
        sys_args = ['prog', '--input-file', 'input.txt', '--mode', 'foo']
        monkeypatch.setattr(sys, 'argv', sys_args)
        with pytest.raises(SystemExit) as exc:
            cli.main()
&gt;       assert exc.value.code == 1
E       assert 2 == 1
E        +  where 2 = SystemExit(2).code
E        +    where SystemExit(2) = &lt;ExceptionInfo SystemExit(2) tblen=7&gt;.value

tests\test_cli_additional.py:41: AssertionError</failure></testcase><testcase classname="tests.test_config_loader" name="test_load_config_with_custom_file" time="0.012" /><testcase classname="tests.test_config_loader" name="test_load_config_with_env_var" time="0.005" /><testcase classname="tests.test_config_loader" name="test_load_config_with_empty_file" time="0.004" /><testcase classname="tests.test_config_loader" name="test_load_config_file_not_found" time="0.003" /><testcase classname="tests.test_config_loader" name="test_load_config_invalid_yaml" time="0.006" /><testcase classname="tests.test_config_loader" name="test_is_examples_file_default" time="0.005"><failure message="ModuleNotFoundError: No module named 'config_loader'">tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_is_examples_file_default0')

    def test_is_examples_file_default(tmp_path):
        """Test is_examples_file_default function."""
&gt;       from config_loader import DEFAULT_EXAMPLES_TEXT
E       ModuleNotFoundError: No module named 'config_loader'

tests\test_config_loader.py:120: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_config_loader" name="test_ensure_config_files_creates_default_examples" time="0.010" /><testcase classname="tests.test_constants" name="test_project_root" time="0.002" /><testcase classname="tests.test_constants" name="test_log_directories" time="0.001" /><testcase classname="tests.test_constants" name="test_batch_size" time="0.001" /><testcase classname="tests.test_constants" name="test_default_model" time="0.001" /><testcase classname="tests.test_constants" name="test_token_limits" time="0.001" /><testcase classname="tests.test_constants" name="test_response_field" time="0.001" /><testcase classname="tests.test_cost_estimator" name="test_load_pricing" time="0.004" /><testcase classname="tests.test_cost_estimator" name="test_estimate_cost_with_valid_model" time="0.005" /><testcase classname="tests.test_cost_estimator" name="test_estimate_cost_with_invalid_model" time="0.003" /><testcase classname="tests.test_cost_estimator" name="test_missing_pricing_file" time="0.001" /><testcase classname="tests.test_cost_estimator" name="test_csv_path_exists" time="0.001" /><testcase classname="tests.test_data_loader" name="test_load_csv_file" time="0.008" /><testcase classname="tests.test_data_loader" name="test_load_json_file" time="0.017" /><testcase classname="tests.test_data_loader" name="test_load_jsonl_file" time="0.009" /><testcase classname="tests.test_data_loader" name="test_save_data_csv" time="0.010" /><testcase classname="tests.test_data_loader" name="test_save_data_json" time="0.011" /><testcase classname="tests.test_data_loader" name="test_save_data_jsonl" time="0.010" /><testcase classname="tests.test_data_loader" name="test_unsupported_file_format_load" time="0.002" /><testcase classname="tests.test_data_loader" name="test_unsupported_file_format_save" time="0.002" /><testcase classname="tests.test_data_loader" name="test_load_nonexistent_file" time="0.002" /><testcase classname="tests.test_evaluator" name="test_load_prompt_template_success" time="0.003" /><testcase classname="tests.test_evaluator" name="test_load_prompt_template_missing_from_yaml_fallback_to_default" time="0.004"><failure message="ModuleNotFoundError: No module named 'config_loader'">def test_load_prompt_template_missing_from_yaml_fallback_to_default():
        """Test fallback to DEFAULT_PROMPTS when prompt is missing from prompts.yaml."""
        with patch('builtins.open', mock_open(read_data="{}")):
            with patch('yaml.safe_load', return_value={}):
&gt;               with patch('config_loader.DEFAULT_PROMPTS',
                           {'batch_evaluation_prompt': DEFAULT_PROMPT_TEXT}):

tests\test_evaluator.py:71: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
C:\Python312\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'config_loader', import_ = &lt;function _gcd_import at 0x000002565EEDC0E0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'config_loader'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_evaluator" name="test_load_prompt_template_file_not_found_fallback" time="0.003"><failure message="ModuleNotFoundError: No module named 'config_loader'">def test_load_prompt_template_file_not_found_fallback():
        """Test fallback to DEFAULT_PROMPTS when prompts.yaml cannot be loaded."""
        with patch('builtins.open', side_effect=FileNotFoundError()):
&gt;           with patch('config_loader.DEFAULT_PROMPTS',
                       {'batch_evaluation_prompt': DEFAULT_PROMPT_TEXT}):

tests\test_evaluator.py:82: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
C:\Python312\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'config_loader', import_ = &lt;function _gcd_import at 0x000002565EEDC0E0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'config_loader'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_evaluator" name="test_load_prompt_template_fail_complete" time="0.004"><failure message="ModuleNotFoundError: No module named 'config_loader'">def test_load_prompt_template_fail_complete():
        """Test complete failure when prompt is not in prompts.yaml or DEFAULT_PROMPTS."""
        with patch('builtins.open', mock_open(read_data="{}")):
            with patch('yaml.safe_load', return_value={}):
&gt;               with patch('config_loader.DEFAULT_PROMPTS', {}):

tests\test_evaluator.py:93: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
C:\Python312\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'config_loader', import_ = &lt;function _gcd_import at 0x000002565EEDC0E0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'config_loader'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_evaluator" name="test_load_prompt_template_yaml_error" time="0.004"><failure message="ModuleNotFoundError: No module named 'config_loader'">def test_load_prompt_template_yaml_error():
        """Test handling of YAML parsing errors."""
        with patch('pathlib.Path.exists', return_value=True), \
             patch('builtins.open', mock_open(read_data="invalid: yaml: content")), \
             patch('yaml.safe_load', side_effect=yaml.YAMLError("Invalid YAML")), \
&gt;            patch('config_loader.DEFAULT_PROMPTS', {'batch_evaluation_prompt': DEFAULT_PROMPT_TEXT}), \
             patch('sys.stderr'):

tests\test_evaluator.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
C:\Python312\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'config_loader', import_ = &lt;function _gcd_import at 0x000002565EEDC0E0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'config_loader'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_evaluator" name="test_load_prompt_template_general_error" time="0.005"><failure message="ModuleNotFoundError: No module named 'config_loader'">def test_load_prompt_template_general_error():
        """Test handling of general exceptions during prompt loading."""
        with patch('pathlib.Path.exists', return_value=True), \
             patch('builtins.open', mock_open(read_data="valid: yaml")), \
             patch('yaml.safe_load', side_effect=Exception("Unexpected error")), \
&gt;            patch('config_loader.DEFAULT_PROMPTS', {'batch_evaluation_prompt': DEFAULT_PROMPT_TEXT}), \
             patch('sys.stderr'):

tests\test_evaluator.py:117: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
C:\Python312\Lib\importlib\__init__.py:90: in import_module
    return _bootstrap._gcd_import(name[level:], package, level)
&lt;frozen importlib._bootstrap&gt;:1387: in _gcd_import
    ???
&lt;frozen importlib._bootstrap&gt;:1360: in _find_and_load
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'config_loader', import_ = &lt;function _gcd_import at 0x000002565EEDC0E0&gt;

&gt;   ???
E   ModuleNotFoundError: No module named 'config_loader'

&lt;frozen importlib._bootstrap&gt;:1324: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[BatchGraderError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[FileProcessingError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[FileNotFoundError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[FilePermissionError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[FileFormatError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[OutputDirectoryError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[DataValidationError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[TokenLimitError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[ChunkingError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_exception_can_be_raised_and_caught[APIError]" time="0.002" /><testcase classname="tests.test_exceptions" name="test_file_processing_error_inheritance" time="0.001"><failure message="assert False&#10; +  where False = issubclass(FileNotFoundError, FileProcessingError)">def test_file_processing_error_inheritance():
        """Test that FileProcessingError subclasses inherit correctly."""
        assert issubclass(FileProcessingError, BatchGraderError)
&gt;       assert issubclass(FileNotFoundError, FileProcessingError)
E       assert False
E        +  where False = issubclass(FileNotFoundError, FileProcessingError)

tests\test_exceptions.py:51: AssertionError</failure></testcase><testcase classname="tests.test_exceptions" name="test_other_exceptions_inherit_from_batch_grader_error" time="0.001" /><testcase classname="tests.test_exceptions" name="test_base_exception_is_generic_exception" time="0.001" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df0-Prompt-response-100-enc-TypeError-df must be a pandas DataFrame]" time="0.001" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df1-Prompt-response-100-enc-TypeError-df must be a pandas DataFrame]" time="0.002" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df2-Prompt-response-100-&lt;lambda&gt;-RuntimeError-encoder fail]" time="1.131" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df3-Prompt-response-1.5-enc-ValueError-token_limit must be a positive integer]" time="0.004" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df4-Prompt-response-not-an-int-enc-ValueError-token_limit must be a positive integer]" time="0.004" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df5-Prompt-response-None-enc-ValueError-token_limit must be a positive integer]" time="0.003" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df6-123-response-100-enc-ValueError-system_prompt_content must be a non-empty string]" time="0.004" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df7-system_prompt7-response-100-enc-ValueError-system_prompt_content must be a non-empty string]" time="0.004" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_raise[df8-Prompt-response-100-enc-ValueError-DataFrame cannot be empty]" time="0.005" /><testcase classname="tests.test_file_processor" name="test_check_token_limits_exotic_cases_no_raise[df0-Prompt-response-100-enc]" time="0.912" /><testcase classname="tests.test_file_processor.TestProcessingStats" name="test_duration_property" time="0.001" /><testcase classname="tests.test_file_processor.TestProcessingStats" name="test_to_dict_method" time="0.001" /><testcase classname="tests.test_file_processor" name="test_check_token_limits" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">sample_df =   custom_id         response other_field  tokens
0         1   First response           a      10
1         2  Second response           b      15
2         3   Third response           c       8, mock_encoder = &lt;MagicMock id='2568744798592'&gt;

    def test_check_token_limits(sample_df, mock_encoder) -&gt; None:
        """Test token limit checking functionality with enhanced assertions.
    
        Args:
            sample_df: Fixture providing a sample DataFrame.
            mock_encoder: Fixture providing a mock encoder.
    
        Returns:
            None
        """
        # Ensure sample_df has the expected 'response' column and isn't empty
        assert 'response' in sample_df.columns
        assert not sample_df.empty
    
        # Mock the logger to prevent TypeError with level comparison
        mock_logger = MagicMock()
    
        # Mock the create_token_counter function to return a simple counter
        def mock_token_counter(row):
            # Simple token counter that returns 10 tokens per row
            return 10
    
&gt;       with patch('src.file_processor.logger', mock_logger), \
             patch('src.file_processor.create_token_counter', return_value=mock_token_counter):

tests\test_file_processor.py:324: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[invalid_df_type-None-Valid prompt-response-100-None-default_encoder-df must be a pandas DataFrame]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256156D3D10&gt;, 'df_override': None, 'encoder_override': 'default_encoder', 'expected_log_message_part': 'df must be a pandas DataFrame', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[empty_df-df_override1-Valid prompt-response-100-None-default_encoder-DataFrame cannot be empty]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256157051F0&gt;, 'df_override': Empty DataFrame
Columns: []
Index: [], 'encoder_override': 'default_encoder', 'expected_log_message_part': 'DataFrame cannot be empty', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[invalid_system_prompt-default-   -response-100-None-default_encoder-system_prompt_content must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256152397F0&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'system_prompt_content must be a non-empty string', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[invalid_response_field_not_in_df-default-Valid prompt-non_existent_field-100-None-default_encoder-response_field 'non_existent_field' not found]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256151F3CB0&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': "response_field 'non_existent_field' not found", ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[null_response_field-default-Valid prompt-None-100-None-default_encoder-response_field must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256151FF200&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'response_field must be a non-empty string', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[empty_string_response_field-default-Valid prompt-   -100-None-default_encoder-response_field must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x000002561572A120&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'response_field must be a non-empty string', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[invalid_token_limit_zero-default-Valid prompt-response-0-None-default_encoder-token_limit must be a positive integer]" time="0.004"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256151F02F0&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'token_limit must be a positive integer', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[invalid_token_limit_negative-default-Valid prompt-response--5-None-default_encoder-token_limit must be a positive integer]" time="0.004"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x000002561523BD70&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'token_limit must be a positive integer', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[null_encoder-default-Valid prompt-response-100-None-None-encoder cannot be None, or tiktoken.Encoding, or a callable.]" time="0.004"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256157C86E0&gt;, 'df_override': 'default', 'encoder_override': None, 'expected_log_message_part': 'encoder cannot be None, or tiktoken.Encoding, or a callable.', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_no_raise[generic_exception_in_try-default-Valid prompt-response-100-mock_create_token_counter_side_effect9-default_encoder-Error checking token limits: Test Counter Error]" time="0.004"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x00000256156EB4D0&gt;, 'df_override': 'default', 'encoder_override': 'default_encoder', 'expected_log_message_part': 'Error checking token limits: Test Counter Error', ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[invalid_df_type-not_a_dataframe-Valid prompt-response-100-None-mock_encoder_val-TypeError-df must be a pandas DataFrame]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'not_a_dataframe', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'df must be a pandas DataFrame', 'expected_exception': &lt;class 'TypeError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[empty_df-df_override1-Valid prompt-response-100-None-mock_encoder_val-ValueError-DataFrame cannot be empty]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': Empty DataFrame
Columns: []
Index: [], 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'DataFrame cannot be empty', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[null_system_prompt-sample_df_val-None-response-100-None-mock_encoder_val-ValueError-system_prompt_content must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'system_prompt_content must be a non-empty string', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[empty_string_system_prompt-sample_df_val-   -response-100-None-mock_encoder_val-ValueError-system_prompt_content must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'system_prompt_content must be a non-empty string', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[null_response_field-sample_df_val-Valid prompt-None-100-None-mock_encoder_val-ValueError-response_field must be a non-empty string]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'response_field must be a non-empty string', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[empty_string_response_field-sample_df_val-Valid prompt-   -100-None-mock_encoder_val-ValueError-response_field must be a non-empty string]" time="0.004"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'response_field must be a non-empty string', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[response_field_not_in_columns-sample_df_val-Valid prompt-non_existent_field-100-None-mock_encoder_val-ValueError-not found in DataFrame columns]" time="0.005"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'not found in DataFrame columns', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[zero_token_limit-sample_df_val-Valid prompt-response-0-None-mock_encoder_val-ValueError-token_limit must be a positive integer]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'token_limit must be a positive integer', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[negative_token_limit-sample_df_val-Valid prompt-response--10-None-mock_encoder_val-ValueError-token_limit must be a positive integer]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': 'mock_encoder_val', 'expected_error_message_part': 'token_limit must be a positive integer', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_check_token_limits_error_paths_raise_error[null_encoder-sample_df_val-Valid prompt-response-100-mock_create_token_counter_side_effect9-None-ValueError-encoder cannot be None, or tiktoken.Encoding, or a callable]" time="0.003"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">args = (), keywargs = {'df_override': 'sample_df_val', 'encoder_override': None, 'expected_error_message_part': 'encoder cannot be None, or tiktoken.Encoding, or a callable', 'expected_exception': &lt;class 'ValueError'&gt;, ...}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_prepare_output_path" time="0.007" /><testcase classname="tests.test_file_processor" name="test_continue_on_chunk_failure" time="0.013"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x0000025615704230&gt;
temp_test_dir_fp = {'base': WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_continue_on_chunk_failure0'), ...wsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_continue_on_chunk_failure0/test_outputs_fp')}
test_config_fp_continue_failure = {'halt_on_chunk_failure': False, 'input_file': 'C:\\Users\\afuny\\AppData\\Local\\Temp\\pytest-of-afuny\\pytest-413\\t...input_for_pfc.csv', 'input_splitter_options': {'max_rows_per_chunk': 3}, 'llm_output_column_name': 'llm_response', ...}

    def test_continue_on_chunk_failure(mocker, temp_test_dir_fp,
                                       test_config_fp_continue_failure):
        # This test is moved from test_batch_runner.py
        # The primary target is now src.file_processor.process_file_concurrently
    
        import yaml
        # Import the already mocked tiktoken module rather than the real one
        from batchgrader.file_processor import process_file_concurrently, BatchJob  # BatchJob for type hint or inspection
        from batchgrader.input_splitter import logger as input_splitter_logger  # Import existing logger from input_splitter
    
        config_to_use = test_config_fp_continue_failure
        # Make sure response_field is explicitly set in the config for consistency
        config_to_use[
            'response_field_name'] = 'llm_response'  # Make this explicit in the config
        config_to_use[
            'llm_output_column_name'] = 'llm_response'  # Ensure both config variables are consistent
        system_prompt_content = config_to_use["system_prompt_content"]
    
        # Now explicitly use this response field name
        response_field = config_to_use['response_field_name']
    
        mock_logger_main = MagicMock()  # Main logger for the test scope
    
        # This flag will be set by the mock if the designated failing chunk is processed
        simulated_chunk_failure_triggered = False
    
        # Create test data for chunks
        chunk1_df = pd.DataFrame([{
            'custom_id': '1',
            'text': 'Text 1'
        }, {
            'custom_id': '2',
            'text': 'Text 2'
        }])
        chunk2_df = pd.DataFrame([{
            'custom_id': '3',
            'text': 'Text 3'
        }, {
            'custom_id': '4',
            'text': 'Text 4'
        }])
        chunk3_df = pd.DataFrame([{
            'custom_id': '5',
            'text': 'Text 5'
        }, {
            'custom_id': '6',
            'text': 'Text 6'
        }])
    
        # Create BatchJob objects for testing
        test_jobs = [
            BatchJob(chunk_id_str="test_input_for_pfc_part1",
                     chunk_df=chunk1_df,
                     system_prompt=system_prompt_content,
                     response_field=response_field,
                     original_filepath=str(config_to_use['input_file']),
                     chunk_file_path="test_input_for_pfc_part1.csv",
                     llm_model=config_to_use.get('openai_model_name'),
                     api_key_prefix="test_key_prefix_fp",
                     status="pending"),
            BatchJob(chunk_id_str="test_input_for_pfc_part2",
                     chunk_df=chunk2_df,
                     system_prompt=system_prompt_content,
                     response_field=response_field,
                     original_filepath=str(config_to_use['input_file']),
                     chunk_file_path="test_input_for_pfc_part2.csv",
                     llm_model=config_to_use.get('openai_model_name'),
                     api_key_prefix="test_key_prefix_fp",
                     status="pending"),
            BatchJob(chunk_id_str="test_input_for_pfc_part3",
                     chunk_df=chunk3_df,
                     system_prompt=system_prompt_content,
                     response_field=response_field,
                     original_filepath=str(config_to_use['input_file']),
                     chunk_file_path="test_input_for_pfc_part3.csv",
                     llm_model=config_to_use.get('openai_model_name'),
                     api_key_prefix="test_key_prefix_fp",
                     status="pending")
        ]
    
        # Mock _generate_chunk_job_objects to return our test jobs
&gt;       mocker.patch('src.file_processor._generate_chunk_job_objects',
                     return_value=test_jobs)

tests\test_file_processor.py:639: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_process_file_common_edge_cases" time="0.006"><failure message="FileNotFoundError: Input file not found: C:\Users\afuny\AppData\Local\Temp\pytest-of-afuny\pytest-413\test_process_file_common_edge_0\input_data\nonexistent.csv">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256151CBDD0&gt;
temp_test_dir_fp = {'base': WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_common_edge_0'), ...wsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_common_edge_0/test_outputs_fp')}

    def test_process_file_common_edge_cases(mocker, temp_test_dir_fp):
        """Test edge cases in process_file_common.
        Uses real file system for existence checks via temp_test_dir_fp.
        """
        from batchgrader.file_processor import process_file_common
    
        # No need to import file_processor module itself if not using patch.object
    
        def test_nonexistent_file_scenario():
            non_existent_file = temp_test_dir_fp["input_data"] / "nonexistent.csv"
            assert not non_existent_file.exists()
    
            with pytest.raises(BatchGraderFileNotFoundError):
                process_file_common(filepath=str(non_existent_file),
                                    output_dir=str(
                                        temp_test_dir_fp["test_outputs"]),
                                    config={},
                                    system_prompt_content="test",
                                    response_field="response",
                                    encoder=mocker.Mock(),
                                    token_limit=100)
    
&gt;       test_nonexistent_file_scenario()

tests\test_file_processor.py:828: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
tests\test_file_processor.py:819: in test_nonexistent_file_scenario
    process_file_common(filepath=str(non_existent_file),
src\batchgrader\file_processor.py:424: in process_file_common
    df = _load_and_validate(filepath)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filepath = 'C:\\Users\\afuny\\AppData\\Local\\Temp\\pytest-of-afuny\\pytest-413\\test_process_file_common_edge_0\\input_data\\nonexistent.csv'

    def _load_and_validate(filepath):
        p_filepath = Path(filepath)
        if not p_filepath.exists():
&gt;           raise FileNotFoundError(f"Input file not found: {filepath}")
E           FileNotFoundError: Input file not found: C:\Users\afuny\AppData\Local\Temp\pytest-of-afuny\pytest-413\test_process_file_common_edge_0\input_data\nonexistent.csv

src\batchgrader\file_processor.py:379: FileNotFoundError</failure></testcase><testcase classname="tests.test_file_processor" name="test_generate_chunk_job_objects_edge_cases" time="0.076"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x000002561523A900&gt;
temp_test_dir_fp = {'base': WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_generate_chunk_job_object0'), ...wsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_generate_chunk_job_object0/test_outputs_fp')}

    def test_generate_chunk_job_objects_edge_cases(mocker, temp_test_dir_fp):
        """Test edge cases in _generate_chunk_job_objects."""
        from batchgrader.file_processor import _generate_chunk_job_objects
    
        # Test invalid encoder
        jobs = _generate_chunk_job_objects(
            original_filepath=str(temp_test_dir_fp["input_data"] / "test.csv"),
            system_prompt_content="test",
            config={},
            tiktoken_encoding_func=mocker.Mock(),  # Mock without encode method
            response_field="response",
            llm_model_name="test-model",
            api_key_prefix="test-key")
        assert len(jobs) == 0
    
        # Test file splitting error
&gt;       mock_split = mocker.patch('src.file_processor.split_file_by_token_limit')

tests\test_file_processor.py:964: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_execute_single_batch_job_task_edge_cases" time="0.749"><failure message="ValueError: Invalid state transition from running to failed">self = Index(['text', 'custom_id'], dtype='object'), key = 'response'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        &gt;&gt;&gt; unique_index = pd.Index(list('abc'))
        &gt;&gt;&gt; unique_index.get_loc('b')
        1
    
        &gt;&gt;&gt; monotonic_index = pd.Index(list('abbc'))
        &gt;&gt;&gt; monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        &gt;&gt;&gt; non_monotonic_index = pd.Index(list('abcb'))
        &gt;&gt;&gt; non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
&gt;           return self._engine.get_loc(casted_key)

C:\Python312\Lib\site-packages\pandas\core\indexes\base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas\\_libs\\hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   KeyError: 'response'

pandas\\_libs\\hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

batch_job = &lt;batchgrader.batch_job.BatchJob object at 0x0000025615707230&gt;, llm_client = &lt;batchgrader.llm_client.LLMClient object at 0x0000025615704650&gt;, response_field_name = 'response', config = None

    def _execute_single_batch_job_task(
            batch_job: BatchJob,
            llm_client: Optional[LLMClient] = None,
            response_field_name: str = "response",
            config: Optional[Dict[str, Any]] = None) -&gt; BatchJob:
        """
        Worker function to process a single BatchJob chunk.
        Updates batch_job status and results in place. Returns the updated batch_job object.
    
        Args:
            batch_job: The BatchJob to process
            llm_client: Optional LLMClient instance. If None, creates a new one for thread safety
            response_field_name: Name of response field to process
            config: Optional configuration dictionary to pass to LLMClient if created
    
        Returns:
            The updated BatchJob object
        """
        if batch_job.chunk_df is None or batch_job.chunk_df.empty:
            if batch_job.status != "error":
                batch_job.status = "error"
                batch_job.error_message = "Chunk DataFrame is None or empty at task execution."
                batch_job.error_details = "Chunk DataFrame was not loaded or was empty when task started."
                logger.error(
                    f"[{batch_job.chunk_id_str}] Skipping task execution: {batch_job.error_message}"
                )
            return batch_job
    
        # Create a new LLMClient if one wasn't provided for thread safety
        if llm_client is None:
            try:
                llm_client = LLMClient(config=config)
                logger.debug(
                    f"[{batch_job.chunk_id_str}] Created new LLMClient instance for thread safety"
                )
            except Exception as e:
                batch_job.status = "error"
                batch_job.error_message = f"Failed to create LLMClient: {str(e)}"
                batch_job.error_details = traceback.format_exc()
                logger.error(
                    f"[{batch_job.chunk_id_str}] {batch_job.error_message}")
                return batch_job
    
        try:
            batch_job.status = "running"
            logger.info(f"[{batch_job.chunk_id_str}] Task starting execution.")
    
            if 'custom_id' not in batch_job.chunk_df.columns:
                logger.warning(
                    f"[{batch_job.chunk_id_str}] 'custom_id' column is missing from chunk_df at the start of _execute_single_batch_job_task."
                )
    
&gt;           api_result = llm_client.run_batch_job(
                batch_job.chunk_df,
                batch_job.system_prompt,
                response_field_name=response_field_name,
                base_filename_for_tagging=batch_job.chunk_id_str)

src\batchgrader\file_processor.py:845: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src\batchgrader\llm_client.py:365: in run_batch_job
    requests_data, df_with_custom_ids = self._prepare_batch_requests(
src\batchgrader\llm_client.py:98: in _prepare_batch_requests
    text_to_evaluate = str(row[response_field_name])
C:\Python312\Lib\site-packages\pandas\core\series.py:1121: in __getitem__
    return self._get_value(key)
C:\Python312\Lib\site-packages\pandas\core\series.py:1237: in _get_value
    loc = self.index.get_loc(label)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['text', 'custom_id'], dtype='object'), key = 'response'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        &gt;&gt;&gt; unique_index = pd.Index(list('abc'))
        &gt;&gt;&gt; unique_index.get_loc('b')
        1
    
        &gt;&gt;&gt; monotonic_index = pd.Index(list('abbc'))
        &gt;&gt;&gt; monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        &gt;&gt;&gt; non_monotonic_index = pd.Index(list('abcb'))
        &gt;&gt;&gt; non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
&gt;           raise KeyError(key) from err
E           KeyError: 'response'

C:\Python312\Lib\site-packages\pandas\core\indexes\base.py:3812: KeyError

During handling of the above exception, another exception occurred:

mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x0000025615704E90&gt;

    def test_execute_single_batch_job_task_edge_cases(mocker):
        """Test edge cases in _execute_single_batch_job_task."""
        from batchgrader.file_processor import _execute_single_batch_job_task
    
        # Test empty DataFrame
        job = create_test_batch_job(chunk_df=None)
&gt;       result = _execute_single_batch_job_task(job)

tests\test_file_processor.py:1010: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src\batchgrader\file_processor.py:881: in _execute_single_batch_job_task
    batch_job.status = "failed"
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;batchgrader.batch_job.BatchJob object at 0x0000025615707230&gt;, new_status = 'failed'

    @status.setter
    def status(self, new_status: str):
        # enforce valid state transitions
        valid_transitions = {
            "pending": ["running", "error"],
            "running": ["completed", "error"],
            "completed": ["error"],
            "error": [],
        }
        old_status = self._status
        if new_status == old_status:
            return
        allowed = valid_transitions.get(old_status, [])
        if new_status not in allowed:
&gt;           raise ValueError(f"Invalid state transition from {old_status} to {new_status}")
E           ValueError: Invalid state transition from running to failed

src\batchgrader\batch_job.py:109: ValueError</failure></testcase><testcase classname="tests.test_file_processor" name="test_process_completed_future_edge_cases" time="0.384"><failure message="ValueError: Invalid state transition from error to completed">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256156FC470&gt;

    def test_process_completed_future_edge_cases(mocker):
        """Test edge cases in _pfc_process_completed_future."""
        from batchgrader.file_processor import _pfc_process_completed_future
    
        # Setup test data
        job = create_test_batch_job()
        future = mocker.Mock()
        future_to_job_map = {future: job}
        completed_jobs = []
        rich_table = mocker.Mock()
        all_jobs = [job]
    
        # Test future processing error
        future.result.side_effect = Exception("Test error")
        should_halt = _pfc_process_completed_future(
            future=future,
            future_to_job_map=future_to_job_map,
            completed_jobs_list=completed_jobs,
            live_display=None,
            rich_table=rich_table,
            all_jobs_list=all_jobs,
            halt_on_failure_flag=True,
            original_filepath="test.csv",
            llm_output_column_name="response")
        assert should_halt
        assert job.status == "error"
        assert job.error_message is not None and "Test error" in str(
            job.error_message)
    
        # Test non-DataFrame result
        future.result.side_effect = None
        future.result.return_value = job
        job.result_data = "not a DataFrame"
&gt;       job.status = "completed"

tests\test_file_processor.py:1057: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;batchgrader.batch_job.BatchJob object at 0x00000256151F2450&gt;, new_status = 'completed'

    @status.setter
    def status(self, new_status: str):
        # enforce valid state transitions
        valid_transitions = {
            "pending": ["running", "error"],
            "running": ["completed", "error"],
            "completed": ["error"],
            "error": [],
        }
        old_status = self._status
        if new_status == old_status:
            return
        allowed = valid_transitions.get(old_status, [])
        if new_status not in allowed:
&gt;           raise ValueError(f"Invalid state transition from {old_status} to {new_status}")
E           ValueError: Invalid state transition from error to completed

src\batchgrader\batch_job.py:109: ValueError</failure></testcase><testcase classname="tests.test_file_processor" name="test_aggregate_and_cleanup_edge_cases" time="0.002"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256157431A0&gt;

    def test_aggregate_and_cleanup_edge_cases(mocker):
        """Test edge cases in _pfc_aggregate_and_cleanup."""
        from batchgrader.file_processor import _pfc_aggregate_and_cleanup, BatchJob
    
        # Create a simplified mock logger to avoid 'Logger has no attribute success' error
        mock_logger = mocker.MagicMock()
&gt;       mocker.patch('src.file_processor.logger', mock_logger)

tests\test_file_processor.py:1080: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_process_file_concurrently_edge_cases" time="0.006"><failure message="AttributeError: module 'src' has no attribute 'file_processor'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x0000025615740E60&gt;
temp_test_dir_fp = {'base': WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_concurrently0'), ...wsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_concurrently0/test_outputs_fp')}

    def test_process_file_concurrently_edge_cases(mocker, temp_test_dir_fp):
        """Test edge cases in process_file_concurrently."""
        from batchgrader.file_processor import process_file_concurrently
    
        # Mock Path for file existence check
&gt;       mock_path = mocker.patch('src.file_processor.Path')  # Fix the patch target

tests\test_file_processor.py:1146: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.file_processor'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'file_processor'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_file_processor" name="test_process_dataframe_with_llm" time="0.005" /><testcase classname="tests.test_file_processor_additional" name="test_prepare_output_path_forced_results" time="0.005" /><testcase classname="tests.test_file_processor_additional" name="test_prepare_output_path_permission_error" time="0.002" /><testcase classname="tests.test_file_processor_additional" name="test_calculate_and_log_token_usage_minimal" time="0.006" /><testcase classname="tests.test_file_processor_additional" name="test_calculate_and_log_token_usage_logging_error" time="0.004" /><testcase classname="tests.test_file_processor_common_paths" name="test_process_file_common_not_found" time="0.006"><failure message="FileNotFoundError: Input file not found: C:\Users\afuny\AppData\Local\Temp\pytest-of-afuny\pytest-413\test_process_file_common_not_f0\nofile.csv">tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_common_not_f0')

    def test_process_file_common_not_found(tmp_path):
        # Path does not exist
        p = tmp_path / "nofile.csv"
        with pytest.raises(FGFileNotFoundError):
&gt;           fp.process_file_common(str(p), str(tmp_path), {}, "prompt", "resp", None, 10)

tests\test_file_processor_common_paths.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src\batchgrader\file_processor.py:424: in process_file_common
    df = _load_and_validate(filepath)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

filepath = 'C:\\Users\\afuny\\AppData\\Local\\Temp\\pytest-of-afuny\\pytest-413\\test_process_file_common_not_f0\\nofile.csv'

    def _load_and_validate(filepath):
        p_filepath = Path(filepath)
        if not p_filepath.exists():
&gt;           raise FileNotFoundError(f"Input file not found: {filepath}")
E           FileNotFoundError: Input file not found: C:\Users\afuny\AppData\Local\Temp\pytest-of-afuny\pytest-413\test_process_file_common_not_f0\nofile.csv

src\batchgrader\file_processor.py:379: FileNotFoundError</failure></testcase><testcase classname="tests.test_file_processor_common_paths" name="test_process_file_common_format_error" time="0.007" /><testcase classname="tests.test_file_processor_common_paths" name="test_process_file_common_empty_df" time="0.010" /><testcase classname="tests.test_file_processor_common_paths" name="test_process_file_common_token_limit_exceeded" time="0.009"><failure message="Failed: DID NOT RAISE &lt;class 'batchgrader.exceptions.TokenLimitError'&gt;">tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_common_token0'), monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x00000256156E8590&gt;

    def test_process_file_common_token_limit_exceeded(tmp_path, monkeypatch):
        # Create dummy CSV path and DataFrame
        p = tmp_path / "data.csv"
        p.write_text('a,b\n1,2')
        df = pd.DataFrame({'a':[1],'b':[2]})
        # load_data returns df
        monkeypatch.setattr(fp, 'load_data', lambda path: df)
        # check_token_limits returns under_limit False
        monkeypatch.setattr(fp, 'check_token_limits', lambda *args, **kwargs: (False, {'total':100}))
        # patch LLMClient and update_token_log
        monkeypatch.setattr(fp, 'LLMClient', DummyClient)
        monkeypatch.setattr(fp, 'update_token_log', lambda *args, **kwargs: None)
&gt;       with pytest.raises(TokenLimitError):
E       Failed: DID NOT RAISE &lt;class 'batchgrader.exceptions.TokenLimitError'&gt;

tests\test_file_processor_common_paths.py:51: Failed</failure></testcase><testcase classname="tests.test_file_processor_common_paths" name="test_process_file_common_success" time="0.008"><failure message="IndexError: tuple index out of range">tmp_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_process_file_common_succe0'), monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x00000256151AF5F0&gt;

    def test_process_file_common_success(tmp_path, monkeypatch):
        p = tmp_path / "data.csv"
        p.write_text('a,b\n1,2')
        df = pd.DataFrame({'a':[1],'b':[2]})
        # load_data returns df
        monkeypatch.setattr(fp, 'load_data', lambda path: df)
        # check_token_limits returns under_limit True
        monkeypatch.setattr(fp, 'check_token_limits', lambda *args, **kwargs: (True, {'total':10}))
        # patch LLMClient and update_token_log
        monkeypatch.setattr(fp, 'LLMClient', DummyClient)
        calls = []
        monkeypatch.setattr(fp, 'update_token_log', lambda *args, **kwargs: calls.append((args,kwargs)))
        success, result = fp.process_file_common(str(p), str(tmp_path), {}, "prompt", "resp", None, 10)
        assert success is True and isinstance(result, pd.DataFrame)
        # ensure update_token_log was called for logging usage
&gt;       assert calls and calls[0][0][1] == 10
E       IndexError: tuple index out of range

tests\test_file_processor_common_paths.py:70: IndexError</failure></testcase><testcase classname="tests.test_file_utils" name="test_prune_chunked_dir" time="0.009" /><testcase classname="tests.test_file_utils" name="test_prune_empty_chunked_dir" time="0.004" /><testcase classname="tests.test_file_utils" name="test_prune_nonexistent_dir" time="0.001" /><testcase classname="tests.test_input_splitter" name="test_split_csv_by_token_limit" time="0.032" /><testcase classname="tests.test_input_splitter" name="test_split_jsonl_by_row_limit" time="0.034" /><testcase classname="tests.test_input_splitter" name="test_split_json_by_force_chunk_count" time="0.032" /><testcase classname="tests.test_input_splitter" name="test_split_df_input" time="0.024" /><testcase classname="tests.test_input_splitter" name="test_empty_input_file" time="0.011" /><testcase classname="tests.test_input_splitter" name="test_empty_df_input" time="0.005" /><testcase classname="tests.test_input_splitter" name="test_single_row_input_fits_in_one_chunk" time="0.017" /><testcase classname="tests.test_input_splitter" name="test_all_rows_fit_in_one_chunk_token_limit" time="0.021" /><testcase classname="tests.test_input_splitter" name="test_all_rows_fit_in_one_chunk_row_limit" time="0.023" /><testcase classname="tests.test_input_splitter" name="test_force_chunk_count_one" time="0.031" /><testcase classname="tests.test_input_splitter" name="test_force_chunk_count_greater_than_rows" time="0.069" /><testcase classname="tests.test_input_splitter" name="test_recursive_split_with_force_chunk_count" time="0.038" /><testcase classname="tests.test_input_splitter" name="test_default_output_dir" time="0.020" /><testcase classname="tests.test_input_splitter" name="test_error_no_limits_provided" time="0.009" /><testcase classname="tests.test_input_splitter" name="test_error_token_limit_no_count_fn" time="0.009" /><testcase classname="tests.test_input_splitter" name="test_error_invalid_force_chunk_count_zero" time="0.010" /><testcase classname="tests.test_input_splitter" name="test_error_invalid_force_chunk_count_negative" time="0.010" /><testcase classname="tests.test_input_splitter" name="test_error_invalid_force_chunk_count_string" time="0.011" /><testcase classname="tests.test_input_splitter" name="test_error_invalid_row_limit_zero" time="0.010" /><testcase classname="tests.test_input_splitter" name="test_error_input_file_not_found" time="0.005" /><testcase classname="tests.test_input_splitter" name="test_error_unsupported_file_type" time="0.006" /><testcase classname="tests.test_input_splitter" name="test_error_df_input_no_original_ext" time="0.008" /><testcase classname="tests.test_input_splitter" name="test_error_df_input_no_file_prefix" time="0.007" /><testcase classname="tests.test_input_splitter" name="test_error_output_dir_none_and_no_input_path" time="0.008" /><testcase classname="tests.test_input_splitter" name="test_error_recursive_call_missing_file_prefix" time="0.005" /><testcase classname="tests.test_input_splitter" name="test_filename_prefixing" time="0.021" /><testcase classname="tests.test_input_splitter" name="test_split_with_response_field_no_functional_change_expected" time="0.023" /><testcase classname="tests.test_input_splitter" name="test_logging_override" time="0.063" /><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_success" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_with_errors" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_critical_failure" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_client_initialization" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_client_init" time="0.002"><failure message="AttributeError: module 'src' has no attribute 'llm_client'">mocker = &lt;pytest_mock.plugin.MockerFixture object at 0x00000256156D6A50&gt;

    def test_llm_client_init(mocker) -&gt; None:
        """Test LLMClient initialization with correct behaviors.
    
        Args:
            mocker: Pytest mocker fixture for mocking dependencies.
    
        Returns:
            None
        """
    
        # Mock get_config_value to return appropriate values based on the key
        def mock_config_getter(config, key, default=None):
            if key == 'max_tokens_per_response':
                return 1000  # Return an integer for max_tokens_per_response
            if key == 'poll_interval_seconds':
                return 60  # Return an integer for poll_interval_seconds
            if key == 'openai_api_key' and not config:
                return "config_api_key"
            return default
    
&gt;       mock_get_config = mocker.patch('src.llm_client.get_config_value')

tests\test_llm_client.py:130: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:440: in __call__
    return self._start_patch(
C:\Users\afuny\AppData\Roaming\Python\Python312\site-packages\pytest_mock\plugin.py:258: in _start_patch
    mocked: MockType = p.start()
C:\Python312\Lib\unittest\mock.py:1624: in start
    result = self.__enter__()
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_basic" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_custom_ids" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_empty_dataframe" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_missing_custom_id" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_with_error" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_malformed" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_retrieve_batch_error_file_success" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_retrieve_batch_error_file_failure" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_process_batch_outputs_completed_with_output" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_process_batch_outputs_completed_no_output" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_process_batch_outputs_failed" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_missing_response_field" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_custom_system_prompt" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_prepare_batch_requests_max_tokens" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_upload_batch_input_file_success" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_manage_batch_job_success" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_process_batch_outputs_success" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_process_batch_outputs_with_errors" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_run_batch_job_integration" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_run_batch_job_default_parameters" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_error_handling" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_parse_batch_output_file_valid_data" time="0.002"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_client" name="test_llm_retrieve_batch_error_file_error_handling" time="0.001"><error message="failed on setup with &quot;AttributeError: module 'src' has no attribute 'llm_client'&quot;">tmp_path_factory = TempPathFactory(_given_basetemp=None, _trace=&lt;pluggy._tracing.TagTracerSub object at 0x000002566429B140&gt;, _basetemp=WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413'), _retention_count=3, _retention_policy='all')

    @pytest.fixture
    def llm_client_instance(tmp_path_factory):
        """
        Provides an LLMClient instance with a mocked OpenAI client.
        """
&gt;       with patch('src.llm_client.OpenAI') as mock_openai_class:

tests\test_llm_client.py:16: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'src.llm_client'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'src' has no attribute 'llm_client'

C:\Python312\Lib\pkgutil.py:528: AttributeError</error></testcase><testcase classname="tests.test_llm_utils" name="test_processing_result" time="0.002" /><testcase classname="tests.test_llm_utils" name="test_get_llm_client" time="0.006" /><testcase classname="tests.test_log_utils" name="test_prune_logs_if_needed_no_pruning_needed" time="0.015" /><testcase classname="tests.test_log_utils" name="test_prune_logs_if_needed_move_to_archive" time="0.016" /><testcase classname="tests.test_log_utils" name="test_prune_logs_if_needed_delete_from_archive" time="0.017" /><testcase classname="tests.test_log_utils" name="test_prune_logs_if_needed_move_and_delete" time="0.021" /><testcase classname="tests.test_log_utils" name="test_prune_logs_if_needed_creates_directories" time="0.008" /><testcase classname="tests.test_log_utils" name="test_prune_logs_with_mocks" time="0.004" /><testcase classname="tests.test_logger" name="test_logger_init_creates_directory" time="0.005" /><testcase classname="tests.test_logger" name="test_logger_init_adds_handlers" time="0.007" /><testcase classname="tests.test_logger" name="test_logger_skips_adding_handlers_if_already_exists" time="0.006" /><testcase classname="tests.test_logger" name="test_logger_methods_call_underlying_logger" time="0.004" /><testcase classname="tests.test_logger" name="test_success_log_level_registered" time="0.001" /><testcase classname="tests.test_logger" name="test_success_method_added_to_logger" time="0.002" /><testcase classname="tests.test_logger" name="test_logger_integration" time="0.012" /><testcase classname="tests.test_logger" name="test_get_logger" time="0.005" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_with_custom_examples" time="0.006" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_with_default_examples" time="0.004" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_missing_examples_file" time="0.003" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_empty_examples_file" time="0.004" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_missing_placeholder" time="0.004" /><testcase classname="tests.test_prompt_utils" name="test_load_system_prompt_missing_config_key" time="0.002" /><testcase classname="tests.test_prompt_utils" name="test_load_prompts_file_not_found" time="0.005" /><testcase classname="tests.test_prompt_utils" name="test_load_prompts_invalid_yaml" time="0.012" /><testcase classname="tests.test_prompt_utils" name="test_load_prompts_invalid_format" time="0.008" /><testcase classname="tests.test_prompt_utils" name="test_load_prompts_success" time="0.009" /><testcase classname="tests.test_prompt_utils" name="test_load_prompts_unexpected_error" time="0.008" /><testcase classname="tests.test_rich_display" name="test_rich_job_table_init" time="0.002" /><testcase classname="tests.test_rich_display" name="test_build_table" time="0.002" /><testcase classname="tests.test_rich_display" name="test_build_table_status_formatting" time="0.002" /><testcase classname="tests.test_rich_display" name="test_build_table_progress_formatting" time="0.003"><failure message="AssertionError: assert '[cyan]▒ ...' in '[cyan]░ 0%[/cyan]'">mock_jobs = [&lt;tests.test_rich_display.MockBatchJob object at 0x000002561565BC20&gt;, &lt;tests.test_rich_display.MockBatchJob object at ...isplay.MockBatchJob object at 0x000002561565BCE0&gt;, &lt;tests.test_rich_display.MockBatchJob object at 0x000002561565BD10&gt;]

    def test_build_table_progress_formatting(mock_jobs):
        """Test that progress indicators are properly formatted in the table."""
        with patch('rich.table.Table.add_row') as mock_add_row:
            table = RichJobTable()
            result = table.build_table(mock_jobs)
    
            calls = mock_add_row.call_args_list
    
            # First job (pending) - 0%
            assert "[yellow]░ 0%" in calls[0][0][3]
    
            # Second job (submitted) - progress indicator
&gt;           assert "[cyan]▒ ..." in calls[1][0][3]
E           AssertionError: assert '[cyan]▒ ...' in '[cyan]░ 0%[/cyan]'

tests\test_rich_display.py:134: AssertionError</failure></testcase><testcase classname="tests.test_rich_display" name="test_print_summary_table" time="0.003" /><testcase classname="tests.test_rich_display" name="test_print_summary_table_content" time="0.004" /><testcase classname="tests.test_splitter" name="test_force_chunk_count_splits_evenly" time="0.022" /><testcase classname="tests.test_splitter" name="test_token_chunking_respects_limit" time="0.026" /><testcase classname="tests.test_splitter" name="test_force_chunk_count_warns_over_token" time="0.018" /><testcase classname="tests.test_splitter" name="test_deep_merge_dicts" time="0.002" /><testcase classname="tests.test_splitter" name="test_examples_file_check" time="0.009" /><testcase classname="tests.test_splitter" name="test_pricing_csv_error" time="0.002" /><testcase classname="tests.test_token_tracker" name="test_get_api_key_prefix" time="0.002" /><testcase classname="tests.test_token_tracker" name="test_load_pricing" time="0.011" /><testcase classname="tests.test_token_tracker" name="test_load_pricing_file_not_found" time="0.006" /><testcase classname="tests.test_token_tracker" name="test_load_log_existing" time="0.008" /><testcase classname="tests.test_token_tracker" name="test_load_log_not_exists" time="0.065" /><testcase classname="tests.test_token_tracker" name="test_load_log_invalid_json" time="0.007" /><testcase classname="tests.test_token_tracker" name="test_save_log" time="0.007" /><testcase classname="tests.test_token_tracker" name="test_update_token_log_existing_entry" time="0.009" /><testcase classname="tests.test_token_tracker" name="test_update_token_log_new_entry" time="0.013" /><testcase classname="tests.test_token_tracker" name="test_log_token_usage_event" time="0.012"><failure message="TypeError: _setup_and_call_log_token_usage_event() got an unexpected keyword argument 'api_key'">temp_event_log_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_log_token_usage_event0/token_usage_events.jsonl')
temp_pricing_csv_path = WindowsPath('C:/Users/afuny/AppData/Local/Temp/pytest-of-afuny/pytest-413/test_log_token_usage_event0/pricing.csv')

    def test_log_token_usage_event(temp_event_log_path: Path,
                                   temp_pricing_csv_path: Path):
        """Test logging a token usage event."""
        # Create a fixed datetime for testing
        fixed_timestamp = "2025-05-16T02:01:23.323343"
&gt;       _setup_and_call_log_token_usage_event(
            fixed_timestamp,
            api_key="sk-1234567890abcdefghijklmn",
            model_str="gpt-4o-mini-2024-07-18",
            input_tokens_int=1000,
            output_tokens_int=500,
            event_log_path_obj=temp_event_log_path,
            pricing_csv_path_obj=temp_pricing_csv_path)
E       TypeError: _setup_and_call_log_token_usage_event() got an unexpected keyword argument 'api_key'

tests\test_token_tracker.py:245: TypeError</failure></testcase><testcase classname="tests.test_token_tracker" name="test_log_token_usage_event_unknown_model" time="0.012" /><testcase classname="tests.test_token_tracker" name="test_load_token_usage_events" time="0.006" /><testcase classname="tests.test_token_tracker" name="test_get_token_usage_summary" time="0.007" /><testcase classname="tests.test_token_tracker" name="test_get_total_cost" time="0.007" /><testcase classname="tests.test_token_tracker" name="test_get_token_usage_for_day" time="0.009" /><testcase classname="tests.test_token_utils" name="test_count_tokens_in_content" time="0.002" /><testcase classname="tests.test_token_utils" name="test_count_tokens_in_content_error_handling" time="0.003" /><testcase classname="tests.test_token_utils" name="test_count_input_tokens" time="0.002" /><testcase classname="tests.test_token_utils" name="test_count_completion_tokens" time="0.002" /><testcase classname="tests.test_token_utils" name="test_create_token_counter" time="0.002" /><testcase classname="tests.test_token_utils" name="test_count_tokens_in_df" time="0.003" /><testcase classname="tests.test_token_utils" name="test_calculate_token_stats" time="0.002" /><testcase classname="tests.test_token_utils" name="test_check_token_limit" time="0.002" /><testcase classname="tests.test_token_utils" name="test_check_token_limit_with_exception" time="0.002" /><testcase classname="tests.test_token_utils" name="test_get_token_count_message" time="0.003" /><testcase classname="tests.test_utils" name="test_get_encoder_default" time="0.002" /><testcase classname="tests.test_utils" name="test_get_encoder_specific_model" time="0.002" /><testcase classname="tests.test_utils" name="test_get_encoder_failure" time="0.004"><failure message="ModuleNotFoundError: No module named 'utils'">args = (), keywargs = {'caplog': &lt;_pytest.logging.LogCaptureFixture object at 0x000002561564BB90&gt;}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'utils', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'utils'

C:\Python312\Lib\importlib\__init__.py:90: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_utils" name="test_deep_merge_dicts_basic" time="0.002" /><testcase classname="tests.test_utils" name="test_deep_merge_dicts_nested" time="0.002" /><testcase classname="tests.test_utils" name="test_deep_merge_dicts_with_non_dict" time="0.002" /><testcase classname="tests.test_utils" name="test_deep_merge_dicts_with_lists" time="0.002" /><testcase classname="tests.test_utils" name="test_deep_merge_dicts_complex" time="0.002" /><testcase classname="tests.test_utils" name="test_ensure_config_files_exist_missing_configs" time="0.005"><failure message="ModuleNotFoundError: No module named 'constants'">args = (), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'constants', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'constants'

C:\Python312\Lib\importlib\__init__.py:90: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_utils" name="test_ensure_config_files_exist_files_already_exist" time="0.004"><failure message="ModuleNotFoundError: No module named 'constants'">args = (), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'constants', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'constants'

C:\Python312\Lib\importlib\__init__.py:90: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_utils" name="test_ensure_config_files_exist_missing_examples" time="0.004"><failure message="ModuleNotFoundError: No module named 'constants'">args = (), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'constants', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'constants'

C:\Python312\Lib\importlib\__init__.py:90: ModuleNotFoundError</failure></testcase><testcase classname="tests.test_utils" name="test_ensure_config_files_exist_error_handling" time="0.005"><failure message="ModuleNotFoundError: No module named 'constants'">args = (), keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Python312\Lib\unittest\mock.py:1393: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
C:\Python312\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Python312\Lib\unittest\mock.py:1375: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Python312\Lib\contextlib.py:526: in enter_context
    result = _enter(cm)
C:\Python312\Lib\unittest\mock.py:1451: in __enter__
    self.target = self.getter()
C:\Python312\Lib\pkgutil.py:513: in resolve_name
    mod = importlib.import_module(modname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'constants', package = None

    def import_module(name, package=None):
        """Import a module.
    
        The 'package' argument is required when performing a relative import. It
        specifies the package to use as the anchor point from which to resolve the
        relative import to an absolute import.
    
        """
        level = 0
        if name.startswith('.'):
            if not package:
                raise TypeError("the 'package' argument is required to perform a "
                                f"relative import for {name!r}")
            for character in name:
                if character != '.':
                    break
                level += 1
&gt;       return _bootstrap._gcd_import(name[level:], package, level)
E       ModuleNotFoundError: No module named 'constants'

C:\Python312\Lib\importlib\__init__.py:90: ModuleNotFoundError</failure></testcase></testsuite></testsuites>